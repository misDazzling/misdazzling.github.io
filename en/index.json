[{"content":"","date":"1 March 2025","externalUrl":null,"permalink":"/en/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"import urllib.request import gzip import io from lxml import etree import json import jsonpath # 1.获取网页源码 # 请求地址 url = \u0026#39;https://www.bilibili.com/video/BV1Es4y1q7Bf/?spm_id_from=333.788.comment.all.click\u0026amp;vd_source=3f0b4e269bbcd37b2419b130c0a77513\u0026#39; # 请求头 headers = { \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36\u0026#39;, \u0026#39;Referer\u0026#39;: \u0026#39;https://www.bilibili.com/\u0026#39;, \u0026#39;Accept\u0026#39;: \u0026#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\u0026#39;, \u0026#39;Accept-Language\u0026#39;: \u0026#39;en-US,en;q=0.5\u0026#39;, \u0026#39;Connection\u0026#39;: \u0026#39;keep-alive\u0026#39;, \u0026#39;Upgrade-Insecure-Requests\u0026#39;: \u0026#39;1\u0026#39;, \u0026#39;TE\u0026#39;: \u0026#39;Trailers\u0026#39; } # 请求对象定制 request = urllib.request.Request(url=url, headers=headers) # 模拟浏览器向服务器发送请求 response = urllib.request.urlopen(request) # 读取响应的内容 content_bytes = response.read() # 从响应中读取的字节数据 # 响应内容是压缩的，需要解压，将压缩的字节数据解压并解码成UTF-8编码的字符串 content_io = io.BytesIO(content_bytes) # 创建了一个io.BytesIO对象，用于将字节数据包装成类似文件对象的形式 # 使用gzip.GzipFile来解压缩数据，mode=\u0026#39;rb\u0026#39;指定以二进制模式读取 with gzip.GzipFile(fileobj=content_io, mode=\u0026#39;rb\u0026#39;) as f: content = f.read().decode(\u0026#39;utf-8\u0026#39;) # # 将网页源码保存到文件“b站视频标题的获取（xpath）.html”中 with open(\u0026#39;b站视频标题的获取（xpath）.html\u0026#39;, \u0026#39;w\u0026#39;, encoding=\u0026#39;UTF-8\u0026#39;) as fp: fp.write(content) # 2.获取视频标题和时长 # （1）处理变成json数据 # 解析服务器响应的文件 etree.HTML tree = etree.HTML(content) # 获取想要的数据 the_data = tree.xpath(\u0026#39;/html/head[@itemprop=\u0026#34;video\u0026#34;]/script[5]/text()\u0026#39;)[0] # 由于tree.xpath返回的是列表，需要使用切片[0]将它取出来 the_json_data = the_data.split(\u0026#39;__=\u0026#39;)[1].split(\u0026#39;;(function\u0026#39;)[0] # （2）处理json数据，得到视频的标题和时长 # 使用jsonpath解析 video_data = json.loads(the_json_data) pages = video_data[\u0026#39;videoData\u0026#39;][\u0026#39;pages\u0026#39;] # 3. 定义一个转换秒数为分:秒格式的函数 def convert_seconds_to_minutes_seconds_format(seconds): minutes = seconds // 60 seconds = seconds % 60 return f\u0026#34;{minutes:02}:{seconds:02}\u0026#34; # 4. 打印每个视频的标题和时长，并累加总时长 total_duration_seconds = 0 # 用于累加总时长 for page in pages: title = page[\u0026#39;part\u0026#39;] # 获取视频的标题 duration = page[\u0026#39;duration\u0026#39;] # 获取视频的时长（单位为秒） # 转换时长为分:秒格式 formatted_duration = convert_seconds_to_minutes_seconds_format(duration) # 打印每个视频的时长 print(f\u0026#34;标题: {title}, 时长: {formatted_duration}\u0026#34;) #print(formatted_duration) # 累加时长 total_duration_seconds += duration def convert_seconds_to_time_format(seconds): # 计算小时 hours = seconds // 3600 # 计算分钟 minutes = (seconds % 3600) // 60 # 计算剩余秒数 seconds = seconds % 60 # 返回格式化的字符串，确保小时、分钟、秒都是两位数 return f\u0026#34;{hours:02}:{minutes:02}:{seconds:02}\u0026#34; # 5. 计算总时长并转换为时:分:秒格式 total_formatted_duration = convert_seconds_to_time_format(total_duration_seconds) print(f\u0026#34;\\n所有视频的总时长: {total_formatted_duration}\u0026#34;) ","date":"1 March 2025","externalUrl":null,"permalink":"/en/posts/crawl-the-duration-and-title-of-bilibili-videos/","section":"Posts","summary":"","title":"Crawl the duration and title of Bilibili videos","type":"posts"},{"content":"import urllib.request import gzip import io from lxml import etree import json import jsonpath # 1.获取网页源码 # 请求地址 url = \u0026#39;https://www.bilibili.com/video/BV1Es4y1q7Bf/?spm_id_from=333.788.comment.all.click\u0026amp;vd_source=3f0b4e269bbcd37b2419b130c0a77513\u0026#39; # 请求头 headers = { \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36\u0026#39;, \u0026#39;Referer\u0026#39;: \u0026#39;https://www.bilibili.com/\u0026#39;, \u0026#39;Accept\u0026#39;: \u0026#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\u0026#39;, \u0026#39;Accept-Language\u0026#39;: \u0026#39;en-US,en;q=0.5\u0026#39;, \u0026#39;Connection\u0026#39;: \u0026#39;keep-alive\u0026#39;, \u0026#39;Upgrade-Insecure-Requests\u0026#39;: \u0026#39;1\u0026#39;, \u0026#39;TE\u0026#39;: \u0026#39;Trailers\u0026#39; } # 请求对象定制 request = urllib.request.Request(url=url, headers=headers) # 模拟浏览器向服务器发送请求 response = urllib.request.urlopen(request) # 读取响应的内容 content_bytes = response.read() # 从响应中读取的字节数据 # 响应内容是压缩的，需要解压，将压缩的字节数据解压并解码成UTF-8编码的字符串 content_io = io.BytesIO(content_bytes) # 创建了一个io.BytesIO对象，用于将字节数据包装成类似文件对象的形式 # 使用gzip.GzipFile来解压缩数据，mode=\u0026#39;rb\u0026#39;指定以二进制模式读取 with gzip.GzipFile(fileobj=content_io, mode=\u0026#39;rb\u0026#39;) as f: content = f.read().decode(\u0026#39;utf-8\u0026#39;) # # 将网页源码保存到文件“b站视频标题的获取（xpath）.html”中 with open(\u0026#39;b站视频标题的获取（xpath）.html\u0026#39;, \u0026#39;w\u0026#39;, encoding=\u0026#39;UTF-8\u0026#39;) as fp: fp.write(content) # 2.获取视频标题和时长 # （1）处理变成json数据 # 解析服务器响应的文件 etree.HTML tree = etree.HTML(content) # 获取想要的数据 the_data = tree.xpath(\u0026#39;/html/head[@itemprop=\u0026#34;video\u0026#34;]/script[5]/text()\u0026#39;)[0] # 由于tree.xpath返回的是列表，需要使用切片[0]将它取出来 the_json_data = the_data.split(\u0026#39;__=\u0026#39;)[1].split(\u0026#39;;(function\u0026#39;)[0] # （2）处理json数据，得到视频的标题和时长 # 使用jsonpath解析 video_data = json.loads(the_json_data) pages = video_data[\u0026#39;videoData\u0026#39;][\u0026#39;pages\u0026#39;] # 3. 定义一个转换秒数为分:秒格式的函数 def convert_seconds_to_minutes_seconds_format(seconds): minutes = seconds // 60 seconds = seconds % 60 return f\u0026#34;{minutes:02}:{seconds:02}\u0026#34; # 4. 打印每个视频的标题和时长，并累加总时长 total_duration_seconds = 0 # 用于累加总时长 for page in pages: title = page[\u0026#39;part\u0026#39;] # 获取视频的标题 duration = page[\u0026#39;duration\u0026#39;] # 获取视频的时长（单位为秒） # 转换时长为分:秒格式 formatted_duration = convert_seconds_to_minutes_seconds_format(duration) # 打印每个视频的时长 print(f\u0026#34;标题: {title}, 时长: {formatted_duration}\u0026#34;) #print(formatted_duration) # 累加时长 total_duration_seconds += duration def convert_seconds_to_time_format(seconds): # 计算小时 hours = seconds // 3600 # 计算分钟 minutes = (seconds % 3600) // 60 # 计算剩余秒数 seconds = seconds % 60 # 返回格式化的字符串，确保小时、分钟、秒都是两位数 return f\u0026#34;{hours:02}:{minutes:02}:{seconds:02}\u0026#34; # 5. 计算总时长并转换为时:分:秒格式 total_formatted_duration = convert_seconds_to_time_format(total_duration_seconds) print(f\u0026#34;\\n所有视频的总时长: {total_formatted_duration}\u0026#34;) ","date":"1 March 2025","externalUrl":null,"permalink":"/en/posts/other/crawl-the-duration-and-title-of-bilibili-videos/","section":"Posts","summary":"","title":"Crawl the duration and title of Bilibili videos","type":"posts"},{"content":"","date":"1 March 2025","externalUrl":null,"permalink":"/en/categories/other/","section":"Categories","summary":"","title":"Other","type":"categories"},{"content":"","date":"1 March 2025","externalUrl":null,"permalink":"/en/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"1 March 2025","externalUrl":null,"permalink":"/en/tags/spider/","section":"Tags","summary":"","title":"Spider","type":"tags"},{"content":"","date":"1 March 2025","externalUrl":null,"permalink":"/en/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"1 March 2025","externalUrl":null,"permalink":"/en/categories/%E6%9D%82%E9%A1%B9/","section":"Categories","summary":"","title":"杂项","type":"categories"},{"content":" I am a master\u0026rsquo;s student majoring in Computer Science, specializing in Embodied Intelligence.\nMy focus is on robotic arm simulation development and large models high-level task planning for robot.\nSometimes, I also write down my thoughts and musings.\nMy notes are mainly recorded on the Yuque platform. Feel free to check out my contact information in the navigation bar.\nYou can learn more about me in the \u0026ldquo;About Me\u0026rdquo; section.\n","date":"1 March 2025","externalUrl":null,"permalink":"/en/","section":"欢迎来到 Blowfish ！","summary":"","title":"欢迎来到 Blowfish ！","type":"page"},{"content":" 代码 # import urllib.request import gzip import io from lxml import etree import json import jsonpath # 1.获取网页源码 # 请求地址 url = \u0026#39;https://www.bilibili.com/video/BV1Es4y1q7Bf/?spm_id_from=333.788.comment.all.click\u0026amp;vd_source=3f0b4e269bbcd37b2419b130c0a77513\u0026#39; # 请求头 headers = { \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36\u0026#39;, \u0026#39;Referer\u0026#39;: \u0026#39;https://www.bilibili.com/\u0026#39;, \u0026#39;Accept\u0026#39;: \u0026#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\u0026#39;, \u0026#39;Accept-Language\u0026#39;: \u0026#39;en-US,en;q=0.5\u0026#39;, \u0026#39;Connection\u0026#39;: \u0026#39;keep-alive\u0026#39;, \u0026#39;Upgrade-Insecure-Requests\u0026#39;: \u0026#39;1\u0026#39;, \u0026#39;TE\u0026#39;: \u0026#39;Trailers\u0026#39; } # 请求对象定制 request = urllib.request.Request(url=url, headers=headers) # 模拟浏览器向服务器发送请求 response = urllib.request.urlopen(request) # 读取响应的内容 content_bytes = response.read() # 从响应中读取的字节数据 # 响应内容是压缩的，需要解压，将压缩的字节数据解压并解码成UTF-8编码的字符串 content_io = io.BytesIO(content_bytes) # 创建了一个io.BytesIO对象，用于将字节数据包装成类似文件对象的形式 # 使用gzip.GzipFile来解压缩数据，mode=\u0026#39;rb\u0026#39;指定以二进制模式读取 with gzip.GzipFile(fileobj=content_io, mode=\u0026#39;rb\u0026#39;) as f: content = f.read().decode(\u0026#39;utf-8\u0026#39;) # # 将网页源码保存到文件“b站视频标题的获取（xpath）.html”中 with open(\u0026#39;b站视频标题的获取（xpath）.html\u0026#39;, \u0026#39;w\u0026#39;, encoding=\u0026#39;UTF-8\u0026#39;) as fp: fp.write(content) # 2.获取视频标题和时长 # （1）处理变成json数据 # 解析服务器响应的文件 etree.HTML tree = etree.HTML(content) # 获取想要的数据 the_data = tree.xpath(\u0026#39;/html/head[@itemprop=\u0026#34;video\u0026#34;]/script[5]/text()\u0026#39;)[0] # 由于tree.xpath返回的是列表，需要使用切片[0]将它取出来 the_json_data = the_data.split(\u0026#39;__=\u0026#39;)[1].split(\u0026#39;;(function\u0026#39;)[0] # （2）处理json数据，得到视频的标题和时长 # 使用jsonpath解析 video_data = json.loads(the_json_data) pages = video_data[\u0026#39;videoData\u0026#39;][\u0026#39;pages\u0026#39;] # 3. 定义一个转换秒数为分:秒格式的函数 def convert_seconds_to_minutes_seconds_format(seconds): minutes = seconds // 60 seconds = seconds % 60 return f\u0026#34;{minutes:02}:{seconds:02}\u0026#34; # 4. 打印每个视频的标题和时长，并累加总时长 total_duration_seconds = 0 # 用于累加总时长 for page in pages: title = page[\u0026#39;part\u0026#39;] # 获取视频的标题 duration = page[\u0026#39;duration\u0026#39;] # 获取视频的时长（单位为秒） # 转换时长为分:秒格式 formatted_duration = convert_seconds_to_minutes_seconds_format(duration) # 打印每个视频的时长 print(f\u0026#34;标题: {title}, 时长: {formatted_duration}\u0026#34;) #print(formatted_duration) # 累加时长 total_duration_seconds += duration def convert_seconds_to_time_format(seconds): # 计算小时 hours = seconds // 3600 # 计算分钟 minutes = (seconds % 3600) // 60 # 计算剩余秒数 seconds = seconds % 60 # 返回格式化的字符串，确保小时、分钟、秒都是两位数 return f\u0026#34;{hours:02}:{minutes:02}:{seconds:02}\u0026#34; # 5. 计算总时长并转换为时:分:秒格式 total_formatted_duration = convert_seconds_to_time_format(total_duration_seconds) print(f\u0026#34;\\n所有视频的总时长: {total_formatted_duration}\u0026#34;) ","date":"1 March 2025","externalUrl":null,"permalink":"/posts/other/%E7%88%AC%E5%8F%96%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9%E8%A7%86%E9%A2%91%E6%97%B6%E9%95%BF%E5%92%8C%E6%A0%87%E9%A2%98/","section":"Posts","summary":"","title":"爬取哔哩哔哩视频时长和标题","type":"posts"},{"content":" 代码 # import urllib.request import gzip import io from lxml import etree import json import jsonpath # 1.获取网页源码 # 请求地址 url = \u0026#39;https://www.bilibili.com/video/BV1Es4y1q7Bf/?spm_id_from=333.788.comment.all.click\u0026amp;vd_source=3f0b4e269bbcd37b2419b130c0a77513\u0026#39; # 请求头 headers = { \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36\u0026#39;, \u0026#39;Referer\u0026#39;: \u0026#39;https://www.bilibili.com/\u0026#39;, \u0026#39;Accept\u0026#39;: \u0026#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\u0026#39;, \u0026#39;Accept-Language\u0026#39;: \u0026#39;en-US,en;q=0.5\u0026#39;, \u0026#39;Connection\u0026#39;: \u0026#39;keep-alive\u0026#39;, \u0026#39;Upgrade-Insecure-Requests\u0026#39;: \u0026#39;1\u0026#39;, \u0026#39;TE\u0026#39;: \u0026#39;Trailers\u0026#39; } # 请求对象定制 request = urllib.request.Request(url=url, headers=headers) # 模拟浏览器向服务器发送请求 response = urllib.request.urlopen(request) # 读取响应的内容 content_bytes = response.read() # 从响应中读取的字节数据 # 响应内容是压缩的，需要解压，将压缩的字节数据解压并解码成UTF-8编码的字符串 content_io = io.BytesIO(content_bytes) # 创建了一个io.BytesIO对象，用于将字节数据包装成类似文件对象的形式 # 使用gzip.GzipFile来解压缩数据，mode=\u0026#39;rb\u0026#39;指定以二进制模式读取 with gzip.GzipFile(fileobj=content_io, mode=\u0026#39;rb\u0026#39;) as f: content = f.read().decode(\u0026#39;utf-8\u0026#39;) # # 将网页源码保存到文件“b站视频标题的获取（xpath）.html”中 with open(\u0026#39;b站视频标题的获取（xpath）.html\u0026#39;, \u0026#39;w\u0026#39;, encoding=\u0026#39;UTF-8\u0026#39;) as fp: fp.write(content) # 2.获取视频标题和时长 # （1）处理变成json数据 # 解析服务器响应的文件 etree.HTML tree = etree.HTML(content) # 获取想要的数据 the_data = tree.xpath(\u0026#39;/html/head[@itemprop=\u0026#34;video\u0026#34;]/script[5]/text()\u0026#39;)[0] # 由于tree.xpath返回的是列表，需要使用切片[0]将它取出来 the_json_data = the_data.split(\u0026#39;__=\u0026#39;)[1].split(\u0026#39;;(function\u0026#39;)[0] # （2）处理json数据，得到视频的标题和时长 # 使用jsonpath解析 video_data = json.loads(the_json_data) pages = video_data[\u0026#39;videoData\u0026#39;][\u0026#39;pages\u0026#39;] # 3. 定义一个转换秒数为分:秒格式的函数 def convert_seconds_to_minutes_seconds_format(seconds): minutes = seconds // 60 seconds = seconds % 60 return f\u0026#34;{minutes:02}:{seconds:02}\u0026#34; # 4. 打印每个视频的标题和时长，并累加总时长 total_duration_seconds = 0 # 用于累加总时长 for page in pages: title = page[\u0026#39;part\u0026#39;] # 获取视频的标题 duration = page[\u0026#39;duration\u0026#39;] # 获取视频的时长（单位为秒） # 转换时长为分:秒格式 formatted_duration = convert_seconds_to_minutes_seconds_format(duration) # 打印每个视频的时长 print(f\u0026#34;标题: {title}, 时长: {formatted_duration}\u0026#34;) #print(formatted_duration) # 累加时长 total_duration_seconds += duration def convert_seconds_to_time_format(seconds): # 计算小时 hours = seconds // 3600 # 计算分钟 minutes = (seconds % 3600) // 60 # 计算剩余秒数 seconds = seconds % 60 # 返回格式化的字符串，确保小时、分钟、秒都是两位数 return f\u0026#34;{hours:02}:{minutes:02}:{seconds:02}\u0026#34; # 5. 计算总时长并转换为时:分:秒格式 total_formatted_duration = convert_seconds_to_time_format(total_duration_seconds) print(f\u0026#34;\\n所有视频的总时长: {total_formatted_duration}\u0026#34;) ","date":"1 March 2025","externalUrl":null,"permalink":"/posts/%E7%88%AC%E5%8F%96%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9%E8%A7%86%E9%A2%91%E6%97%B6%E9%95%BF%E5%92%8C%E6%A0%87%E9%A2%98/","section":"Posts","summary":"","title":"爬取哔哩哔哩视频时长和标题","type":"posts"},{"content":"","date":"1 March 2025","externalUrl":null,"permalink":"/en/tags/%E7%88%AC%E8%99%AB/","section":"Tags","summary":"","title":"爬虫","type":"tags"},{"content":"Hello! I am a master\u0026rsquo;s student majoring in Computer Science, specializing in Embodied Intelligence. My main focus is on robotic arm simulation development and high-level task planning for large models. Sometimes, I also write some of my thoughts and musings. I mainly record my notes on the Yuque platform. Feel free to follow my contact information in the navigation bar.\nFeel free to contact me and my email is : misdazzling01@gmail.com 经历和项目 # voxPoser复现 2024-07 voxPoser 解决官方仓库部署的bug：VoxPoser: Composable 3D Value Maps for Robotic Manipulation with Language Models 微信公众号接入chatgpt 2023-09 chatgpt-wechat 为你的微信公众号接入chatgpt，免服务器 开源项目 # misDazzling/VoxPoser 复现VoxPoser HTML 14 3 misDazzling/chatgpt-wechat 为你的微信公众号接入chatgpt，免服务器，只需APIkey。 JavaScript 11 3 ","externalUrl":null,"permalink":"/en/about/","section":"欢迎来到 Blowfish ！","summary":"","title":"About Me","type":"page"},{"content":"","externalUrl":null,"permalink":"/en/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/en/series/","section":"Series","summary":"","title":"Series","type":"series"}]