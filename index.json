[{"content":"","date":"1 March 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"import urllib.request import gzip import io from lxml import etree import json import jsonpath # 1.获取网页源码 # 请求地址 url = \u0026#39;https://www.bilibili.com/video/BV1Es4y1q7Bf/?spm_id_from=333.788.comment.all.click\u0026amp;vd_source=3f0b4e269bbcd37b2419b130c0a77513\u0026#39; # 请求头 headers = { \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36\u0026#39;, \u0026#39;Referer\u0026#39;: \u0026#39;https://www.bilibili.com/\u0026#39;, \u0026#39;Accept\u0026#39;: \u0026#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\u0026#39;, \u0026#39;Accept-Language\u0026#39;: \u0026#39;en-US,en;q=0.5\u0026#39;, \u0026#39;Connection\u0026#39;: \u0026#39;keep-alive\u0026#39;, \u0026#39;Upgrade-Insecure-Requests\u0026#39;: \u0026#39;1\u0026#39;, \u0026#39;TE\u0026#39;: \u0026#39;Trailers\u0026#39; } # 请求对象定制 request = urllib.request.Request(url=url, headers=headers) # 模拟浏览器向服务器发送请求 response = urllib.request.urlopen(request) # 读取响应的内容 content_bytes = response.read() # 从响应中读取的字节数据 # 响应内容是压缩的，需要解压，将压缩的字节数据解压并解码成UTF-8编码的字符串 content_io = io.BytesIO(content_bytes) # 创建了一个io.BytesIO对象，用于将字节数据包装成类似文件对象的形式 # 使用gzip.GzipFile来解压缩数据，mode=\u0026#39;rb\u0026#39;指定以二进制模式读取 with gzip.GzipFile(fileobj=content_io, mode=\u0026#39;rb\u0026#39;) as f: content = f.read().decode(\u0026#39;utf-8\u0026#39;) # # 将网页源码保存到文件“b站视频标题的获取（xpath）.html”中 with open(\u0026#39;b站视频标题的获取（xpath）.html\u0026#39;, \u0026#39;w\u0026#39;, encoding=\u0026#39;UTF-8\u0026#39;) as fp: fp.write(content) # 2.获取视频标题和时长 # （1）处理变成json数据 # 解析服务器响应的文件 etree.HTML tree = etree.HTML(content) # 获取想要的数据 the_data = tree.xpath(\u0026#39;/html/head[@itemprop=\u0026#34;video\u0026#34;]/script[5]/text()\u0026#39;)[0] # 由于tree.xpath返回的是列表，需要使用切片[0]将它取出来 the_json_data = the_data.split(\u0026#39;__=\u0026#39;)[1].split(\u0026#39;;(function\u0026#39;)[0] # （2）处理json数据，得到视频的标题和时长 # 使用jsonpath解析 video_data = json.loads(the_json_data) pages = video_data[\u0026#39;videoData\u0026#39;][\u0026#39;pages\u0026#39;] # 3. 定义一个转换秒数为分:秒格式的函数 def convert_seconds_to_minutes_seconds_format(seconds): minutes = seconds // 60 seconds = seconds % 60 return f\u0026#34;{minutes:02}:{seconds:02}\u0026#34; # 4. 打印每个视频的标题和时长，并累加总时长 total_duration_seconds = 0 # 用于累加总时长 for page in pages: title = page[\u0026#39;part\u0026#39;] # 获取视频的标题 duration = page[\u0026#39;duration\u0026#39;] # 获取视频的时长（单位为秒） # 转换时长为分:秒格式 formatted_duration = convert_seconds_to_minutes_seconds_format(duration) # 打印每个视频的时长 print(f\u0026#34;标题: {title}, 时长: {formatted_duration}\u0026#34;) #print(formatted_duration) # 累加时长 total_duration_seconds += duration def convert_seconds_to_time_format(seconds): # 计算小时 hours = seconds // 3600 # 计算分钟 minutes = (seconds % 3600) // 60 # 计算剩余秒数 seconds = seconds % 60 # 返回格式化的字符串，确保小时、分钟、秒都是两位数 return f\u0026#34;{hours:02}:{minutes:02}:{seconds:02}\u0026#34; # 5. 计算总时长并转换为时:分:秒格式 total_formatted_duration = convert_seconds_to_time_format(total_duration_seconds) print(f\u0026#34;\\n所有视频的总时长: {total_formatted_duration}\u0026#34;) ","date":"1 March 2025","externalUrl":null,"permalink":"/en/posts/crawl-the-duration-and-title-of-bilibili-videos/","section":"Posts","summary":"","title":"Crawl the duration and title of Bilibili videos","type":"posts"},{"content":"import urllib.request import gzip import io from lxml import etree import json import jsonpath # 1.获取网页源码 # 请求地址 url = \u0026#39;https://www.bilibili.com/video/BV1Es4y1q7Bf/?spm_id_from=333.788.comment.all.click\u0026amp;vd_source=3f0b4e269bbcd37b2419b130c0a77513\u0026#39; # 请求头 headers = { \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36\u0026#39;, \u0026#39;Referer\u0026#39;: \u0026#39;https://www.bilibili.com/\u0026#39;, \u0026#39;Accept\u0026#39;: \u0026#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\u0026#39;, \u0026#39;Accept-Language\u0026#39;: \u0026#39;en-US,en;q=0.5\u0026#39;, \u0026#39;Connection\u0026#39;: \u0026#39;keep-alive\u0026#39;, \u0026#39;Upgrade-Insecure-Requests\u0026#39;: \u0026#39;1\u0026#39;, \u0026#39;TE\u0026#39;: \u0026#39;Trailers\u0026#39; } # 请求对象定制 request = urllib.request.Request(url=url, headers=headers) # 模拟浏览器向服务器发送请求 response = urllib.request.urlopen(request) # 读取响应的内容 content_bytes = response.read() # 从响应中读取的字节数据 # 响应内容是压缩的，需要解压，将压缩的字节数据解压并解码成UTF-8编码的字符串 content_io = io.BytesIO(content_bytes) # 创建了一个io.BytesIO对象，用于将字节数据包装成类似文件对象的形式 # 使用gzip.GzipFile来解压缩数据，mode=\u0026#39;rb\u0026#39;指定以二进制模式读取 with gzip.GzipFile(fileobj=content_io, mode=\u0026#39;rb\u0026#39;) as f: content = f.read().decode(\u0026#39;utf-8\u0026#39;) # # 将网页源码保存到文件“b站视频标题的获取（xpath）.html”中 with open(\u0026#39;b站视频标题的获取（xpath）.html\u0026#39;, \u0026#39;w\u0026#39;, encoding=\u0026#39;UTF-8\u0026#39;) as fp: fp.write(content) # 2.获取视频标题和时长 # （1）处理变成json数据 # 解析服务器响应的文件 etree.HTML tree = etree.HTML(content) # 获取想要的数据 the_data = tree.xpath(\u0026#39;/html/head[@itemprop=\u0026#34;video\u0026#34;]/script[5]/text()\u0026#39;)[0] # 由于tree.xpath返回的是列表，需要使用切片[0]将它取出来 the_json_data = the_data.split(\u0026#39;__=\u0026#39;)[1].split(\u0026#39;;(function\u0026#39;)[0] # （2）处理json数据，得到视频的标题和时长 # 使用jsonpath解析 video_data = json.loads(the_json_data) pages = video_data[\u0026#39;videoData\u0026#39;][\u0026#39;pages\u0026#39;] # 3. 定义一个转换秒数为分:秒格式的函数 def convert_seconds_to_minutes_seconds_format(seconds): minutes = seconds // 60 seconds = seconds % 60 return f\u0026#34;{minutes:02}:{seconds:02}\u0026#34; # 4. 打印每个视频的标题和时长，并累加总时长 total_duration_seconds = 0 # 用于累加总时长 for page in pages: title = page[\u0026#39;part\u0026#39;] # 获取视频的标题 duration = page[\u0026#39;duration\u0026#39;] # 获取视频的时长（单位为秒） # 转换时长为分:秒格式 formatted_duration = convert_seconds_to_minutes_seconds_format(duration) # 打印每个视频的时长 print(f\u0026#34;标题: {title}, 时长: {formatted_duration}\u0026#34;) #print(formatted_duration) # 累加时长 total_duration_seconds += duration def convert_seconds_to_time_format(seconds): # 计算小时 hours = seconds // 3600 # 计算分钟 minutes = (seconds % 3600) // 60 # 计算剩余秒数 seconds = seconds % 60 # 返回格式化的字符串，确保小时、分钟、秒都是两位数 return f\u0026#34;{hours:02}:{minutes:02}:{seconds:02}\u0026#34; # 5. 计算总时长并转换为时:分:秒格式 total_formatted_duration = convert_seconds_to_time_format(total_duration_seconds) print(f\u0026#34;\\n所有视频的总时长: {total_formatted_duration}\u0026#34;) ","date":"1 March 2025","externalUrl":null,"permalink":"/en/posts/other/crawl-the-duration-and-title-of-bilibili-videos/","section":"Posts","summary":"","title":"Crawl the duration and title of Bilibili videos","type":"posts"},{"content":"","date":"1 March 2025","externalUrl":null,"permalink":"/en/categories/other/","section":"Categories","summary":"","title":"Other","type":"categories"},{"content":"","date":"1 March 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"1 March 2025","externalUrl":null,"permalink":"/en/tags/spider/","section":"Tags","summary":"","title":"Spider","type":"tags"},{"content":"","date":"1 March 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" 我是一名计算机专业, 具身智能方向的在读硕士研究生，\n以机械臂仿真开发、大模型高层任务规划为主，\n有时也会写下一些我的杂谈与随想。\n笔记主要在语雀平台记录，欢迎关注导航栏我的相关联系方式。\n你可以在 about me 了解更多关于我的信息。\n","date":"1 March 2025","externalUrl":null,"permalink":"/","section":"欢迎来到 Blowfish! 🎉","summary":"","title":"欢迎来到 Blowfish! 🎉","type":"page"},{"content":"","date":"1 March 2025","externalUrl":null,"permalink":"/tags/%E7%88%AC%E8%99%AB/","section":"Tags","summary":"","title":"爬虫","type":"tags"},{"content":" 代码 # import urllib.request import gzip import io from lxml import etree import json import jsonpath # 1.获取网页源码 # 请求地址 url = \u0026#39;https://www.bilibili.com/video/BV1Es4y1q7Bf/?spm_id_from=333.788.comment.all.click\u0026amp;vd_source=3f0b4e269bbcd37b2419b130c0a77513\u0026#39; # 请求头 headers = { \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36\u0026#39;, \u0026#39;Referer\u0026#39;: \u0026#39;https://www.bilibili.com/\u0026#39;, \u0026#39;Accept\u0026#39;: \u0026#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\u0026#39;, \u0026#39;Accept-Language\u0026#39;: \u0026#39;en-US,en;q=0.5\u0026#39;, \u0026#39;Connection\u0026#39;: \u0026#39;keep-alive\u0026#39;, \u0026#39;Upgrade-Insecure-Requests\u0026#39;: \u0026#39;1\u0026#39;, \u0026#39;TE\u0026#39;: \u0026#39;Trailers\u0026#39; } # 请求对象定制 request = urllib.request.Request(url=url, headers=headers) # 模拟浏览器向服务器发送请求 response = urllib.request.urlopen(request) # 读取响应的内容 content_bytes = response.read() # 从响应中读取的字节数据 # 响应内容是压缩的，需要解压，将压缩的字节数据解压并解码成UTF-8编码的字符串 content_io = io.BytesIO(content_bytes) # 创建了一个io.BytesIO对象，用于将字节数据包装成类似文件对象的形式 # 使用gzip.GzipFile来解压缩数据，mode=\u0026#39;rb\u0026#39;指定以二进制模式读取 with gzip.GzipFile(fileobj=content_io, mode=\u0026#39;rb\u0026#39;) as f: content = f.read().decode(\u0026#39;utf-8\u0026#39;) # # 将网页源码保存到文件“b站视频标题的获取（xpath）.html”中 with open(\u0026#39;b站视频标题的获取（xpath）.html\u0026#39;, \u0026#39;w\u0026#39;, encoding=\u0026#39;UTF-8\u0026#39;) as fp: fp.write(content) # 2.获取视频标题和时长 # （1）处理变成json数据 # 解析服务器响应的文件 etree.HTML tree = etree.HTML(content) # 获取想要的数据 the_data = tree.xpath(\u0026#39;/html/head[@itemprop=\u0026#34;video\u0026#34;]/script[5]/text()\u0026#39;)[0] # 由于tree.xpath返回的是列表，需要使用切片[0]将它取出来 the_json_data = the_data.split(\u0026#39;__=\u0026#39;)[1].split(\u0026#39;;(function\u0026#39;)[0] # （2）处理json数据，得到视频的标题和时长 # 使用jsonpath解析 video_data = json.loads(the_json_data) pages = video_data[\u0026#39;videoData\u0026#39;][\u0026#39;pages\u0026#39;] # 3. 定义一个转换秒数为分:秒格式的函数 def convert_seconds_to_minutes_seconds_format(seconds): minutes = seconds // 60 seconds = seconds % 60 return f\u0026#34;{minutes:02}:{seconds:02}\u0026#34; # 4. 打印每个视频的标题和时长，并累加总时长 total_duration_seconds = 0 # 用于累加总时长 for page in pages: title = page[\u0026#39;part\u0026#39;] # 获取视频的标题 duration = page[\u0026#39;duration\u0026#39;] # 获取视频的时长（单位为秒） # 转换时长为分:秒格式 formatted_duration = convert_seconds_to_minutes_seconds_format(duration) # 打印每个视频的时长 print(f\u0026#34;标题: {title}, 时长: {formatted_duration}\u0026#34;) #print(formatted_duration) # 累加时长 total_duration_seconds += duration def convert_seconds_to_time_format(seconds): # 计算小时 hours = seconds // 3600 # 计算分钟 minutes = (seconds % 3600) // 60 # 计算剩余秒数 seconds = seconds % 60 # 返回格式化的字符串，确保小时、分钟、秒都是两位数 return f\u0026#34;{hours:02}:{minutes:02}:{seconds:02}\u0026#34; # 5. 计算总时长并转换为时:分:秒格式 total_formatted_duration = convert_seconds_to_time_format(total_duration_seconds) print(f\u0026#34;\\n所有视频的总时长: {total_formatted_duration}\u0026#34;) ","date":"1 March 2025","externalUrl":null,"permalink":"/posts/other/%E7%88%AC%E5%8F%96%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9%E8%A7%86%E9%A2%91%E6%97%B6%E9%95%BF%E5%92%8C%E6%A0%87%E9%A2%98/","section":"Posts","summary":"","title":"爬取哔哩哔哩视频时长和标题","type":"posts"},{"content":" 代码 # import urllib.request import gzip import io from lxml import etree import json import jsonpath # 1.获取网页源码 # 请求地址 url = \u0026#39;https://www.bilibili.com/video/BV1Es4y1q7Bf/?spm_id_from=333.788.comment.all.click\u0026amp;vd_source=3f0b4e269bbcd37b2419b130c0a77513\u0026#39; # 请求头 headers = { \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36\u0026#39;, \u0026#39;Referer\u0026#39;: \u0026#39;https://www.bilibili.com/\u0026#39;, \u0026#39;Accept\u0026#39;: \u0026#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\u0026#39;, \u0026#39;Accept-Language\u0026#39;: \u0026#39;en-US,en;q=0.5\u0026#39;, \u0026#39;Connection\u0026#39;: \u0026#39;keep-alive\u0026#39;, \u0026#39;Upgrade-Insecure-Requests\u0026#39;: \u0026#39;1\u0026#39;, \u0026#39;TE\u0026#39;: \u0026#39;Trailers\u0026#39; } # 请求对象定制 request = urllib.request.Request(url=url, headers=headers) # 模拟浏览器向服务器发送请求 response = urllib.request.urlopen(request) # 读取响应的内容 content_bytes = response.read() # 从响应中读取的字节数据 # 响应内容是压缩的，需要解压，将压缩的字节数据解压并解码成UTF-8编码的字符串 content_io = io.BytesIO(content_bytes) # 创建了一个io.BytesIO对象，用于将字节数据包装成类似文件对象的形式 # 使用gzip.GzipFile来解压缩数据，mode=\u0026#39;rb\u0026#39;指定以二进制模式读取 with gzip.GzipFile(fileobj=content_io, mode=\u0026#39;rb\u0026#39;) as f: content = f.read().decode(\u0026#39;utf-8\u0026#39;) # # 将网页源码保存到文件“b站视频标题的获取（xpath）.html”中 with open(\u0026#39;b站视频标题的获取（xpath）.html\u0026#39;, \u0026#39;w\u0026#39;, encoding=\u0026#39;UTF-8\u0026#39;) as fp: fp.write(content) # 2.获取视频标题和时长 # （1）处理变成json数据 # 解析服务器响应的文件 etree.HTML tree = etree.HTML(content) # 获取想要的数据 the_data = tree.xpath(\u0026#39;/html/head[@itemprop=\u0026#34;video\u0026#34;]/script[5]/text()\u0026#39;)[0] # 由于tree.xpath返回的是列表，需要使用切片[0]将它取出来 the_json_data = the_data.split(\u0026#39;__=\u0026#39;)[1].split(\u0026#39;;(function\u0026#39;)[0] # （2）处理json数据，得到视频的标题和时长 # 使用jsonpath解析 video_data = json.loads(the_json_data) pages = video_data[\u0026#39;videoData\u0026#39;][\u0026#39;pages\u0026#39;] # 3. 定义一个转换秒数为分:秒格式的函数 def convert_seconds_to_minutes_seconds_format(seconds): minutes = seconds // 60 seconds = seconds % 60 return f\u0026#34;{minutes:02}:{seconds:02}\u0026#34; # 4. 打印每个视频的标题和时长，并累加总时长 total_duration_seconds = 0 # 用于累加总时长 for page in pages: title = page[\u0026#39;part\u0026#39;] # 获取视频的标题 duration = page[\u0026#39;duration\u0026#39;] # 获取视频的时长（单位为秒） # 转换时长为分:秒格式 formatted_duration = convert_seconds_to_minutes_seconds_format(duration) # 打印每个视频的时长 print(f\u0026#34;标题: {title}, 时长: {formatted_duration}\u0026#34;) #print(formatted_duration) # 累加时长 total_duration_seconds += duration def convert_seconds_to_time_format(seconds): # 计算小时 hours = seconds // 3600 # 计算分钟 minutes = (seconds % 3600) // 60 # 计算剩余秒数 seconds = seconds % 60 # 返回格式化的字符串，确保小时、分钟、秒都是两位数 return f\u0026#34;{hours:02}:{minutes:02}:{seconds:02}\u0026#34; # 5. 计算总时长并转换为时:分:秒格式 total_formatted_duration = convert_seconds_to_time_format(total_duration_seconds) print(f\u0026#34;\\n所有视频的总时长: {total_formatted_duration}\u0026#34;) ","date":"1 March 2025","externalUrl":null,"permalink":"/posts/%E7%88%AC%E5%8F%96%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9%E8%A7%86%E9%A2%91%E6%97%B6%E9%95%BF%E5%92%8C%E6%A0%87%E9%A2%98/","section":"Posts","summary":"","title":"爬取哔哩哔哩视频时长和标题","type":"posts"},{"content":"","date":"1 March 2025","externalUrl":null,"permalink":"/categories/%E6%9D%82%E9%A1%B9/","section":"Categories","summary":"","title":"杂项","type":"categories"},{"content":"你好！我是一名计算机专业, 具身智能方向的在读硕士研究生， 以机械臂仿真开发、大模型高层任务规划为主， 有时也会写下一些我的杂谈与随想。 笔记主要在语雀平台记录，欢迎关注导航栏我的相关联系方式。\n欢迎与我联系，我的个人邮箱是: misdazzling01@gmail.com 经历和项目 # voxPoser复现 2024-07 voxPoser 解决官方仓库部署的bug：VoxPoser: Composable 3D Value Maps for Robotic Manipulation with Language Models 微信公众号接入chatgpt 2023-09 chatgpt-wechat 为你的微信公众号接入chatgpt，免服务器 开源项目 # misDazzling/VoxPoser 复现VoxPoser HTML 14 3 misDazzling/chatgpt-wechat 为你的微信公众号接入chatgpt，免服务器，只需APIkey。 JavaScript 11 3 ","externalUrl":null,"permalink":"/about/","section":"欢迎来到 Blowfish! 🎉","summary":"","title":"About Me","type":"page"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]